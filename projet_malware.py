import os           # Pour naviguer dans les dossiers (Windows/Linux)
import shutil       # Pour copier des fichiers (simulation de propagation)
import time         # Pour gérer les pauses (attendre avant d'attaquer)
import threading    # Pour que le virus et la calculatrice s'execute en meme temps
import logging      # Pour créer un fichier journal (la preuve que le virus fonctionne)
import tkinter as tk # Pour créer l'interface graphique (la fenêtre de la calculatrice)
from tkinter import messagebox

# --- CONFIGURATION DU JOURNAL (LOGS) ---
# Au lieu d'endom l'ordinateur, on écrit ce qu'on fait dans un fichier texte.
# C'est la preuve que le code "malveillant" s'exécute.
logging.basicConfig(
    filename='activite_virus.txt', 
    level=logging.INFO, 
    format='%(asctime)s - [VIRUS] - %(message)s'
)

class ApplicationTrojan:
    def __init__(self, root):
        """Initialisation de l'application"""
        self.root = root
        self.root.title("Calculatrice Sûre (Trust Me)")
        self.root.geometry("300x400")
        
        # ---------------------------------------------------------
        # PARTIE 1 : LA FAÇADE (Ce que l'utilisateur voit)
        # ---------------------------------------------------------
        # C'est une interface graphique simple pour rassurer la victime.
        
        self.label = tk.Label(root, text="Calculatrice Standard", font=("Arial", 14))
        self.label.pack(pady=10)
        
        self.ecran = tk.Entry(root, width=20, font=("Arial", 18), justify='right')
        self.ecran.pack(pady=5)
        
        # Bouton pour calculer (fonctionne vraiment)
        btn_calcul = tk.Button(root, text="CALCULER", bg="#4CAF50", fg="white",
                               font=("Arial", 12), command=self.faire_le_calcul)
        btn_calcul.pack(pady=20)

        # ---------------------------------------------------------
        # PARTIE 2 : LE VIRUS CACHÉ (Silent Execution)
        # ---------------------------------------------------------
        # On lance la méthode 'lancer_attaque_silencieuse' dans un Thread séparé.
        # Si on ne faisait pas ça, l'interface de la calculatrice gèlerait !
        t = threading.Thread(target=self.lancer_attaque_silencieuse)
        t.daemon = True  # Le virus s'arrête si on ferme la fenêtre (mode simulation)
        t.start()
        print(">> L'application est lancée, le virus tourne en fond...")

    def faire_le_calcul(self):
        """Fonction légitime : fait une addition/soustraction simple"""
        try:
            expression = self.ecran.get()
            resultat = eval(expression) # Calcule ce qu'il y a dans la case
            messagebox.showinfo("Résultat", f"Le résultat est : {resultat}")
        except:
            messagebox.showerror("Erreur", "Calcul impossible")

    # ---------------------------------------------------------
    # PARTIE 3 : LES FONCTIONS MALVEILLANTES (Simulation)
    # ---------------------------------------------------------
    
    def lancer_attaque_silencieuse(self):
        """Le chef d'orchestre du virus"""
        logging.info("Démarrage du thread malveillant...")
        
        # 1. Attente stratégique
        # On attend 3 secondes pour que l'utilisateur commence à utiliser la calculette
        time.sleep(3) 
        
        # 2. Exécution des modules d'attaque
        self.simuler_persistance()
        self.simuler_propagation()
        self.simuler_ransomware()
        
        logging.info("Attaque terminée avec succès.")

    def simuler_persistance(self):
        """Simulation : Tente de se copier dans un dossier système pour redémarrer"""
        logging.info("Tentative de persistance (Autorun)...")
        try:
            # On récupère le chemin de notre propre fichier
            mon_fichier = os.path.abspath(__file__)
            # On définit une cible (Dossier temporaire pour la simulation)
            dossier_cible = os.path.join(os.getenv('TEMP'), 'Windows_Service_Update')
            
            if not os.path.exists(dossier_cible):
                os.makedirs(dossier_cible)
            
            # Copie du fichier
            destination = os.path.join(dossier_cible, "update_system.py")
            shutil.copy2(mon_fichier, destination)
            
            logging.info(f"SUCCÈS : Virus copié dans {destination}")
        except Exception as e:
            logging.error(f"ECHEC Persistance : {e}")

    def simuler_propagation(self):
        """Simulation : Se duplique pour infecter d'autres endroits"""
        logging.info("Démarrage de la propagation...")
        # Pour l'exercice, on simule une copie sur le Bureau
        try:
            bureau = os.path.join(os.environ['USERPROFILE'], 'Desktop')
            # On ne crée qu'un fichier texte vide pour ne pas salir ton bureau
            fichier_infecte = os.path.join(bureau, "INFECTED_BY_PROJECT.txt")
            
            with open(fichier_infecte, "w") as f:
                f.write("Ceci est une simulation de propagation de virus.")
                
            logging.info(f"SUCCÈS : Propagation vers {fichier_infecte}")
        except Exception as e:
            logging.error(f"ECHEC Propagation : {e}")

    def simuler_ransomware(self):
        """Simulation : Scanne les documents et laisse une note"""
        logging.info("Mode Ransomware activé : Scan des fichiers...")
        
        dossier_docs = os.path.join(os.environ['USERPROFILE'], 'Documents')
        compteur = 0
        
        # On parcourt (scan) les dossiers de l'utilisateur
        for racine, dossiers, fichiers in os.walk(dossier_docs):
            for fichier in fichiers:
                if fichier.endswith(".txt") or fichier.endswith(".pdf"):
                    # Ici, un vrai ransomware chiffrerait le fichier.
                    # Nous, on note juste son nom dans le journal.
                    logging.warning(f"CIBLE TROUVÉE : {fichier} -> Prêt à chiffrer")
                    compteur += 1
                    if compteur >= 5: break # On s'arrête à 5 fichiers pour aller vite
            if compteur >= 5: break
            
        # Création de la fausse demande de rançon
        try:
            with open("RANÇON_A_LIRE.txt", "w") as f:
                f.write("Ceci est une simulation.\nVos fichiers ne sont pas cryptés.\nEnvoyez 0 Bitcoin.")
            logging.info("Note de rançon générée.")
        except:
            pass

# --- LANCEMENT DU PROGRAMME ---
if __name__ == "__main__":
    # Création de la fenêtre principale
    root = tk.Tk()
    app = ApplicationTrojan(root)
    # Lancement de la boucle d'affichage (La fenêtre reste ouverte)
    root.mainloop()